#!/bin/env raku
use Proc::Easier;
use Data::Dump;
use Data::Dump::Tree;
use File::Find;
use Font::FreeType;
use Font::FreeType::Face;
use Font::FreeType::Raw::Defs;

my $HOME = %*ENV<HOME> // '.';
my $pdir = $*CWD.IO.parent;
#say "DEBUG: parent dir is: $pdir"; exit;

my $ofil  = "$HOME/.fontfactory/system-fonts.list";
my $ofil2 = "$pdir/lib/FontFactory/FontList.rakumod";

# the following files are for development and are not generated
# if the 'build' mode is selected
my $ofil3 = "$pdir/dev/FontList.rakumod";
my $ofil4 = "$pdir/dev/system-fonts.list";
my $ofil5 = "$pdir/dev/system-fonts-dups.list";

if not @*ARGS {
    print qq:to/HERE/;
    Usage: {$*PROGRAM.basename} go | debug | build

    Finds TrueType, OpenType, and Type 1 font files and creates a list in
    a user's \$HOME in a file named 
        $ofil
    and two unique hashes in file 
        $ofil2

    If the build mode is not used, other files generated are
        $ofil3
        $ofil4
        $ofil5
        
    HERE
    exit;
}

my $debug = 0;;
my $build = 0;;
++$debug if @*ARGS.head ~~ /^:i d/;
++$build if @*ARGS.head ~~ /^:i build/;

# get the list using binary fc-list from package fontconfig
my $exe     = "fc-list";
my $res     = cmd $exe;
my @fc-list = $res.out.lines;

if $debug {
    .say for @fc-list;
    say "Found {@fc-list.elems} fc-list files";
    say "Debug: dumping fc-list after collecting the list. Early exit";
    exit;
}

my %fonts; # hash to hold fonts keyed by basename (eliminate extensions !~~ /'.' [otf|ttf|t1]
my $dups = 0;  
my %dups;  
my $maxlen = 0;
my $maxnam = '';
my $ft = Font::FreeType.new;
LINE: for @fc-list -> $line {
    # parse the line
    # the first field is the path to the font file
    my $path = $line.words.head;

    # skip all but standard system directories
    # /usr/share/fonts
    # /usr/share/X11/fonts/Type1
    # /usr/share/X11/fonts/TTF
    # /usr/local/share/fonts
    # ~/.fonts

    next LINE unless $path ~~ /^
        | '/usr/share/fonts'
        | '/usr/share/X11/fonts/Type1'
        | '/usr/share/X11/fonts/TTF'
        | '/usr/local/share/fonts'
        | '~/.fonts'
    /;

    # not interested in other than these for now
    next LINE unless $path ~~ /'.' [otf|ttf|t1] ':' $/;

    # get rid of the closing ':'
    $path ~~ s/':'$//;

    # skip files without kerning
    # get the kern capability
    # must be scalable
    # must be outline
    my $f = $ft.face: $path, :load-flags(FT_LOAD_NO_HINTING);
    next if not $f.is-scalable;
    
    my $font = $path.IO.basename;
    if %dups{$font}:exists {
        ++$dups;
        ++%dups{$font}; 
    }
    else {
        %dups{$font} = 1;; 
    }

    my $dir  = $path.IO.parent;

    %fonts{$font}<dirs>{$dir} = 1;

    # mark fonts with kern data
    if $f.has-kerning {
        %fonts{$font}<has-kerning> = True;
    }
    else {
        %fonts{$font}<has-kerning> = False;
    }

    my $len = $font.chars;
    if $len > $maxlen {
        $maxlen = $len;
        $maxnam = $font;
    }
}
 
#ddt %fonts; exit;


# create the home .fontfactory dir
my $hdir = "$HOME/.fontfactory";
unless $hdir.IO.d {
    mkdir $hdir;
}

my $fh = open $ofil, :w;
my $index = 0;
my %fonts-indexed;
my @indices;
my $nkerning = 0;
for %fonts.keys.sort -> $font {
    ++$index;
    my $dir = %fonts{$font}<dirs>.head.key;
    $fh.say: sprintf '%4d %s %s', $index, $font, $dir;

    my $kern = %fonts{$font}<has-kerning>;
    ++$nkerning if $kern;

    %fonts{$font}<index> = $index;
    %fonts-indexed{$index} = { font => $font, dir => $dir, has-kerning => $kern };
    @indices.push: $index;
}
$fh.close;

if $debug {
    say "Creating a hash for FontFactory::FontList use...";
}

$fh = open $ofil2, :w;

# write the constant, top part
$fh.print: qq:to/HERE/;
unit module FontFactory::FontList;

constant %Fonts is export = [
    # These are the TrueType, OpenType, and Type 1 
    # fonts found on the local host as well as any
    # in file '\$HOME/.fontfactory/myfonts.list'.
HERE

my @b = %fonts.keys.sort;
# write the variable, middle part
for @b -> $font {
    #my $dir   = %(%fonts{$font}<dirs>).head;
    my $dir   = %fonts{$font}<dirs>.head.key;
    my $index = %fonts{$font}<index>;
    my $kern  = %fonts{$font}<has-kerning>;
    $fh.print: qq:to/HERE/;
        '$font' => \{ 
            index       => $index,
              dir       => '$dir',
            has-kerning => $kern,
        },
    HERE      
}

# write the constant, end part
$fh.print: qq:to/HERE/;
];

# invert the hash and have short names (aliases) as keys
constant %FontAliases is export = [
HERE      
# write the variable, middle part
for @indices -> $index {
    my $dir   = %fonts-indexed{$index}<dir>;
    my $font  = %fonts-indexed{$index}<font>;
    my $kern  = %fonts-indexed{$index}<has-kerning>;
    $fh.print: qq:to/HERE/;
        $index => \{ 
                   font => '$font',
                    dir => '$dir',
            has-kerning => $kern,
        },
    HERE      
}
$fh.say: '];';
$fh.close;

exit if $build;

if $dups {
    $fh = open $ofil5, :w;
    for %fonts.keys.sort -> $font {
        if %fonts{$font}<dirs>.elems > 1 {
            $fh.say: $font;
            for %fonts{$font}<dirs>.keys.sort -> $dir {
                $fh.say: "    $dir";
            }
        }
    }
    $fh.close;
}

# copy rakumod to the dev dir
copy $ofil2, $ofil3;

say "Normal end.";
my $nf = %fonts.elems;
say "Found $nf TrueType, OpenType, and Type 1 font files.";
say "Found $dups duplicate font files." if $dups;
say "Found $nkerning fonts with kerning data.";
say "Creating a list of unique font files...";
say "  note: max length of basenames: $maxlen";
say "        basename:                $maxnam";
say "See output file '$ofil'.";
say "See output file '$ofil2'.";
say "See output file '$ofil3'.";
say "See output file '$ofil4'.";
if $dups {
    say "See output file '$ofil5'.";
}

